# 2606 바이러스
[백준 2606번](https://www.acmicpc.net/problem/2606)
- 풀이 방법 : DFS 사용  
    인접한 노드의 개수를 구하는 문제로, BFS와 DFS로의 구현이 모두 가능하다.   
    BFS로의 구현은 BFS폴더에 존재한다. 두 방법 모두 구현해본 결과, DFS의 코드 길이가 훨씬 짧으며 구현이 간단하다.  

- 문제 해결
1) 사용자에게 컴퓨터의 개수와 간선의 개수 입력 받고, 간선의 정보까지 입력받기
2) 간선의 정보를 graph 배열에 저장하며, 이때 대칭적으로 저장된다.
3) DFS 함수를 호출한다. 시작 정점은 1번 이다.

- 코드 살펴보기
    - 초기 전변변수 선언 및 초기화
    ```
    int n, edge;
    int graph[101][101];
    int visited[101] = {0};
    int ans = 0;
    ```
    n은 컴퓨터의 개수, edge는 입력받을 간선의 개수  
    graph 2차원 배열에는 간선의 정보를 저장하며, 대칭적으로 저장된다.  
    visited 배열은 방문 정보를 저장하는 배열이며, 방문하지 않은 상태는 0이고 방문했다면 1이다. 0으로 초기화한다.  
    ans는 감염되는 컴퓨터의 개수를 셀 정답 변수이다.  

    - 간선의 정보를 저장할 함수
    ```
    void graphConnection(int x, int y){
        graph[x][y] = 1;
        graph[y][x] = 1;
    }
    ```
    사용자에게 간선의 정보를 입력받으면, 두 정점을 인자로 받아 graph에 간선의 정보를 저장한다.  
    예를 들어 1과 2를 연결했다면, 2와 1도 연결되는 것이 당연하므로 대칭적으로 1로 저장한다.  

    - DFS 함수
    ```
    void dfs(int start){
        visited[start] = 1; // 시작 정점 방문 표시
        
        for(int i = 1; i <= n; i++){
            if (graph[start][i] == 1 && visited[i] == 0){
                ans++;
                dfs(i);
            }
        }
    }
    ```
    가장 처음에 시작 정점을 인자로 받아 호출된다.  
    시작 정점을 방문했기 때문에 해당 visited 배열을 1로 갱신한다.  
    n만큼 반복문을 돌면서, 간선이 존재하고 && 방문하지 않은 정점이 있다면 재귀호출로 dfs를 호출한다.  
    이때, ans의 값은 증가한다.  
    